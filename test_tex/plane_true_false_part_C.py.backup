import math
import random
from typing import List, Tuple, Dict

# Formatters

def format_plane_equation(a: float, b: float, c: float, d: float) -> str:
    parts: List[str] = []
    if a == 1:
        parts.append("x")
    elif a == -1:
        parts.append("-x")
    elif a != 0:
        if a == int(a):
            parts.append(f"{int(a)}x")
        else:
            parts.append(f"{a}x")
    if b != 0:
        if parts:
     PART_C_GROUPS: List[List] = [
    [prop_tangent_plane_at_point],
    [prop_plane_parallel_tangent_to_sphere],
    [prop_radius_from_center_plane_distance],
    [prop_plane_sphere_no_intersection_param],
    [prop_plane_parallel_equidistant_two_planes],
    [prop_plane_sphere_intersection_circumference],
    [prop_plane_through_points_equidistant],
    [prop_param_plane_tangent_sphere],
    [prop_param_plane_intersect_sphere_circle],
    [prop_sphere_plane_intersection_given_radius],
    [prop_sphere_plane_intersection_given_area],
    [prop_plane_distance_to_point],
    [prop_plane_angle_with_coordinate_plane],
    [prop_sphere_general_form_center_radius],
    [prop_plane_through_three_points]
]== 1:
                parts.append("+ y")
            elif b == -1:
                parts.append("- y")
            elif b > 0:
                if b == int(b):
                    parts.append(f"+ {int(b)}y")
                else:
                    parts.append(f"+ {b}y")
            else:
                if b == int(b):
                    parts.append(f"- {int(abs(b))}y")
                else:
                    parts.append(f"- {abs(b)}y")
        else:
            if b == 1:
                parts.append("y")
            elif b == -1:
                parts.append("-y")
            else:
                if b == int(b):
                    parts.append(f"{int(b)}y")
                else:
                    parts.append(f"{b}y")
    if c != 0:
        if parts:
            if c == 1:
                parts.append("+ z")
            elif c == -1:
                parts.append("- z")
            elif c > 0:
                if c == int(c):
                    parts.append(f"+ {int(c)}z")
                else:
                    parts.append(f"+ {c}z")
            else:
                if c == int(c):
                    parts.append(f"- {int(abs(c))}z")
                else:
                    parts.append(f"- {abs(c)}z")
        else:
            if c == 1:
                parts.append("z")
            elif c == -1:
                parts.append("-z")
            else:
                if c == int(c):
                    parts.append(f"{int(c)}z")
                else:
                    parts.append(f"{c}z")
    if d != 0:
        if d > 0 and parts:
            if d == int(d):
                parts.append(f"+ {int(d)}")
            else:
                parts.append(f"+ {d}")
        else:
            if d == int(d):
                parts.append(str(int(d)))
            else:
                parts.append(str(d))
    if not parts:
        parts.append("0")
    return " ".join(parts) + " = 0"


def format_point(pt: Tuple[int, int, int]) -> str:
    return f"({pt[0]};{pt[1]};{pt[2]})"

# Helpers

def point_plane_distance_numer_normsq(a: int, b: int, c: int, d: int, P: Tuple[int, int, int]) -> Tuple[int, int]:
    numer = abs(a*P[0] + b*P[1] + c*P[2] + d)
    norm_sq = a*a + b*b + c*c
    return numer, norm_sq


def sphere_center_radius_from_eq(A: int, B: int, C: int, D: int) -> Tuple[Tuple[float, float, float], float]:
    # x^2 + y^2 + z^2 + 2ux + 2vy + 2wz + D = 0 => center (-u, -v, -w), r^2 = u^2+v^2+w^2 - D
    u, v, w = A/2.0, B/2.0, C/2.0
    cx, cy, cz = -u, -v, -w
    r_sq = u*u + v*v + w*w - D
    r = math.sqrt(abs(r_sq))
    return (cx, cy, cz), r

# Propositions for Part C

# Tangent plane at a point on sphere

def prop_tangent_plane_at_point() -> Dict[str, str]:
    # Sphere: (x-1)^2 + (y+1)^2 + (z-3)^2 = 9; point M(2,1,1) genericized
    center = (random.randint(-2, 2), random.randint(-2, 2), random.randint(-2, 2))
    r = random.choice([3, 4, 5])
    # pick a point on sphere by offsetting along x
    M = (center[0] + r, center[1], center[2])
    # Tangent plane normal is vector CM
    a, b, c = (M[0]-center[0], M[1]-center[1], M[2]-center[2])
    d = -(a*M[0] + b*M[1] + c*M[2])
    true_text = f"Mặt phẳng tiếp xúc với mặt cầu tâm I{format_point(center)} bán kính {r} tại M{format_point(M)} có phương trình \\((P): {format_plane_equation(a,b,c,d)}\\)."
    false_text = f"Mặt phẳng tiếp xúc với mặt cầu tâm I{format_point(center)} bán kính {r} tại M{format_point(M)} có phương trình \\((P): {format_plane_equation(a,b,c,d+1)}\\)."
    return {"true": true_text, "false": false_text}

# Plane parallel to given plane and tangent to sphere

def prop_plane_parallel_tangent_to_sphere() -> Dict[str, str]:
    # Sphere general: x^2+y^2+z^2+2ux+2vy+2wz + D = 0
    u, v, w = random.randint(-3, 3), random.randint(-3, 3), random.randint(-3, 3)
    D = random.randint(-10, 5)
    center = (-u, -v, -w)
    r = math.sqrt(max(0.0, u*u + v*v + w*w - D))
    # Given plane: ax+by+cz+d0=0, parallel planes: same (a,b,c) with different d
    a, b, c = random.choice([1, 2, 3]), random.choice([1, 2]), random.choice([-2, -1, 1, 2])
    d0 = random.randint(-10, 10)
    # Distance from center to plane equals radius at tangency: |a*cx+b*cy+c*cz + d| / sqrt(a^2+b^2+c^2) = r
    numer_c = abs(a*center[0] + b*center[1] + c*center[2])
    norm = math.sqrt(a*a + b*b + c*c)
    # d_true candidates: d = ±(r*norm) - (a*cx+b*cy+c*cz)
    offset = r*norm
    d_true = - (a*center[0] + b*center[1] + c*center[2]) + offset
    d_false = d_true + random.choice([1, -1, 2, -2])
    true_text = f"Tồn tại mặt phẳng \\((Q)\\) song song với \\((P): {format_plane_equation(a,b,c,int(d0))}\\) và tiếp xúc với mặt cầu \\(x^2+y^2+z^2+{2*u}x+{2*v}y+{2*w}z+{D}=0\\) có dạng \\((Q): {format_plane_equation(a,b,c,int(round(d_true)))}\\)."
    false_text = f"\\((Q): {format_plane_equation(a,b,c,int(round(d_false)))}\\) cũng là mặt phẳng tiếp xúc như trên."
    return {"true": true_text, "false": false_text}

# Distance from center to plane equals radius

def prop_radius_from_center_plane_distance() -> Dict[str, str]:
    a, b, c = 4, 3, -2
    d = 1
    I = (0, -2, 1)
    numer, norm_sq = point_plane_distance_numer_normsq(a, b, c, d, I)
    true_text = f"Hình cầu tâm I{format_point(I)} tiếp xúc với mặt phẳng \\((P): {format_plane_equation(a,b,c,d)}\\) có bán kính \\(\\dfrac{{{numer}}}{{\\sqrt{{{norm_sq}}}}}\\)."
    false_text = f"Hình cầu tâm I{format_point(I)} tiếp xúc với mặt phẳng \\((P): {format_plane_equation(a,b,c,d)}\\) có bán kính \\(\\dfrac{{{numer+1}}}{{\\sqrt{{{norm_sq}}}}}\\)."
    return {"true": true_text, "false": false_text}

# Non-intersection (no common point) condition between plane and sphere parameter m

def prop_plane_sphere_no_intersection_param() -> Dict[str, str]:
    # Sphere: (x+1)^2+(y-2)^2+(z-3)^2 = 25 -> x^2+y^2+z^2+2x-4y-6z-11=0
    # Plane: 2x+y-2z+m=0; no intersection if distance from center > radius
    center = (-1, 2, 3)
    r = 5
    a, b, c = 2, 1, -2
    # distance |a*cx+b*cy+c*cz + m| / sqrt(a^2+b^2+c^2) > r => |a*cx+b*cy+c*cz + m| > r*norm
    base = a*center[0] + b*center[1] + c*center[2]
    norm = math.sqrt(a*a + b*b + c*c)
    threshold = r*norm
    # Choose m so that |base + m| > threshold
    m_true = int(math.copysign(math.ceil(threshold) + random.randint(0, 3), random.choice([-1, 1]))) - base
    true_text = f"Với \\((P): 2x+y-2z+m=0\\) và mặt cầu \\((S): (x+1)^2+(y-2)^2+(z-3)^2=25\\), khi \\(m\\) đủ lớn về trị tuyệt đối thì \\((P)\\) và \\((S)\\) không có điểm chung."
    false_text = f"Với \\((P): 2x+y-2z+m=0\\) và \\((S)\\) như trên, luôn tồn tại giao tuyến là đường tròn với mọi \\(m\\)."
    return {"true": true_text, "false": false_text}

# Plane parallel and equidistant to two given planes

def prop_plane_parallel_equidistant_two_planes() -> Dict[str, str]:
    # Two parallel planes: ax+by+cz+d1=0 and ax+by+cz+d2=0
    a, b, c = random.choice([1, 2, 3]), random.choice([-1, 1]), random.choice([2, 4])
    d1, d2 = random.randint(-5, 5), random.randint(6, 15)
    if d1 > d2:
        d1, d2 = d2, d1
    # Middle plane has d = (d1+d2)/2
    d_middle = (d1 + d2) / 2
    true_text = f"Cho hai mặt phẳng \\((\\alpha): {format_plane_equation(a,b,c,d1)}\\) và \\((\\beta): {format_plane_equation(a,b,c,d2)}\\). Mặt phẳng \\((P)\\) song song và cách đều hai mặt phẳng \\((\\alpha)\\) và \\((\\beta)\\) có phương trình \\((P): {format_plane_equation(a,b,c,d_middle)}\\)."
    false_text = f"Mặt phẳng \\((P): {format_plane_equation(a,b,c,d_middle+1)}\\) cũng song song và cách đều hai mặt phẳng trên."
    return {"true": true_text, "false": false_text}

# Plane parallel to given plane and intersects sphere with specific circumference

def prop_plane_sphere_intersection_circumference() -> Dict[str, str]:
    # Sphere: (x-h)^2+(y-k)^2+(z-l)^2=R^2
    center = (random.randint(-2, 2), random.randint(-2, 2), random.randint(-2, 2))
    R = random.choice([4, 5, 6])
    # Given plane: ax+by+cz+d0=0, parallel plane: ax+by+cz+d=0
    a, b, c = random.choice([1, 2]), random.choice([1, 2]), random.choice([-1, 1])
    d0 = random.randint(-10, 10)
    # Circumference = 2πr, given circumference = 6π => r = 3
    r_circle = 3
    # Distance from center to plane: sqrt(R^2 - r^2)
    dist_center_plane = math.sqrt(R*R - r_circle*r_circle)
    norm = math.sqrt(a*a + b*b + c*c)
    # |a*h + b*k + c*l + d| / norm = dist_center_plane
    base = a*center[0] + b*center[1] + c*center[2]
    d_true = -base + dist_center_plane * norm
    d_false = -base + (dist_center_plane + 1) * norm
    
    # Format sphere equation properly
    cx_term = f"(x{-center[0]:+})" if center[0] != 0 else "x"
    cy_term = f"(y{-center[1]:+})" if center[1] != 0 else "y"
    cz_term = f"(z{-center[2]:+})" if center[2] != 0 else "z"
    sphere_eq = f"{cx_term}^2+{cy_term}^2+{cz_term}^2={R*R}"
    
    true_text = f"Mặt phẳng \\((P)\\) song song với \\((Q): {format_plane_equation(a,b,c,d0)}\\) và cắt mặt cầu \\((S): {sphere_eq}\\) theo giao tuyến là đường tròn có chu vi \\(6\\pi\\) có phương trình \\((P): {format_plane_equation(a,b,c,d_true)}\\)."
    false_text = f"Mặt phẳng \\((P): {format_plane_equation(a,b,c,d_false)}\\) cũng thỏa mãn điều kiện trên."
    return {"true": true_text, "false": false_text}

# Plane through two points and equidistant to two other points

def prop_plane_through_points_equidistant() -> Dict[str, str]:
    # Two points on plane
    O = (0, 0, 0)
    A = (random.choice([1, 2]), random.choice([1, 2]), 0)
    # Two points to be equidistant
    B = (0, random.choice([3, 4]), 0)
    C = (0, 0, random.choice([2, 3]))
    # Plane through O, A has form: by + cz = 0 (since it passes through origin)
    # Normal vector perpendicular to OA = A
    # Let plane be: bx + cy + dz = 0, substitute A: b*A[0] + c*A[1] + d*A[2] = 0
    # Distance from B to plane = distance from C to plane
    # |b*B[0] + c*B[1] + d*B[2]| / sqrt(b^2+c^2+d^2) = |b*C[0] + c*C[1] + d*C[2]| / sqrt(b^2+c^2+d^2)
    # For plane passing through O(0,0,0) and A(1,2,0): normal can be (b,c,d) where b*1 + c*2 + d*0 = 0 => b = -2c
    # So plane: -2cx + cy + dz = 0 or c(-2x + y) + dz = 0
    # Simplify: take c=1, then -2x + y + (d)z = 0
    # Distance B to plane: |-2*0 + 1*B[1] + d*0| = |B[1]| = B[1]
    # Distance C to plane: |-2*0 + 1*0 + d*C[2]| = |d*C[2]|
    # Equidistant: B[1] = |d*C[2]| => d = ±B[1]/C[2]
    d_coeff = B[1] / C[2]
    # Two solutions: d = B[1]/C[2] or d = -B[1]/C[2]
    true_text = f"Mặt phẳng \\((P)\\) đi qua hai điểm \\(O{format_point(O)}\\), \\(A{format_point(A)}\\) và cách đều hai điểm \\(B{format_point(B)}\\), \\(C{format_point(C)}\\) có dạng \\(6x-3y±4z=0\\)."
    false_text = f"Chỉ có duy nhất một mặt phẳng thỏa mãn điều kiện trên."
    return {"true": true_text, "false": false_text}

# Parameter for plane to be tangent to sphere

def prop_param_plane_tangent_sphere() -> Dict[str, str]:
    # Sphere: x^2+y^2+z^2+2ux+2vy+2wz+D=0, center (-u,-v,-w), r^2=u^2+v^2+w^2-D
    u, v, w = random.choice([-1, 1]), random.choice([-2, 2]), random.choice([-3, 3])
    D = random.randint(-5, 0)
    center = (-u, -v, -w)
    r_sq = u*u + v*v + w*w - D
    r = math.sqrt(r_sq)
    # Plane: ax+by+cz+m=0
    a, b, c = random.choice([1, 2]), random.choice([1, 2]), random.choice([1, 2])
    # Tangency: distance from center to plane = radius
    # |a*(-u) + b*(-v) + c*(-w) + m| / sqrt(a^2+b^2+c^2) = r
    norm = math.sqrt(a*a + b*b + c*c)
    base = -a*u - b*v - c*w
    # |base + m| = r * norm
    # m = -base ± r*norm
    m1 = -base + r * norm
    m2 = -base - r * norm
    
    # Format sphere equation
    sphere_terms = []
    sphere_terms.append("x^2+y^2+z^2")
    if u != 0:
        sphere_terms.append(f"{2*u:+}x")
    if v != 0:
        sphere_terms.append(f"{2*v:+}y")
    if w != 0:
        sphere_terms.append(f"{2*w:+}z")
    if D != 0:
        sphere_terms.append(f"{D:+}")
    sphere_eq = "".join(sphere_terms) + "=0"
    
    # Format plane equation parts
    plane_parts = []
    if a != 0:
        if a == 1:
            plane_parts.append("x")
        elif a == -1:
            plane_parts.append("-x")
        else:
            plane_parts.append(f"{a}x")
    if b != 0:
        if plane_parts:
            if b > 0:
                plane_parts.append(f"+{b}y" if b != 1 else "+y")
            else:
                plane_parts.append(f"{b}y" if b != -1 else "-y")
        else:
            plane_parts.append(f"{b}y" if b not in [1, -1] else ("y" if b == 1 else "-y"))
    if c != 0:
        if plane_parts:
            if c > 0:
                plane_parts.append(f"+{c}z" if c != 1 else "+z")
            else:
                plane_parts.append(f"{c}z" if c != -1 else "-z")
        else:
            plane_parts.append(f"{c}z" if c not in [1, -1] else ("z" if c == 1 else "-z"))
    plane_base = "".join(plane_parts)
    
    true_text = f"Cho mặt cầu \\((S): {sphere_eq}\\) và mặt phẳng \\((P): {plane_base}+m=0\\). Để \\((P)\\) tiếp xúc với \\((S)\\), ta có \\(m={m1:.1f}\\) hoặc \\(m={m2:.1f}\\)."
    false_text = f"Chỉ có duy nhất giá trị \\(m={m1:.1f}\\) để \\((P)\\) tiếp xúc với \\((S)\\)."
    return {"true": true_text, "false": false_text}

# Parameter for plane to intersect sphere as circle

def prop_param_plane_intersect_sphere_circle() -> Dict[str, str]:
    # Sphere: x^2+y^2+z^2+Ax+By+Cz+D=0
    A, B, C = random.choice([-2, 2]), random.choice([-2, 2]), random.choice([-2, 2])
    D = random.randint(-8, -5)
    center = (-A/2, -B/2, -C/2)
    r_sq = (A*A + B*B + C*C)/4 - D
    r = math.sqrt(r_sq)
    # Plane: ax+by+m=0 (missing z for simplicity)
    a, b = random.choice([3, 4]), random.choice([3, 4])
    # For intersection to be a circle: distance from center < radius
    # |a*(-A/2) + b*(-B/2) + m| / sqrt(a^2+b^2) < r
    norm = math.sqrt(a*a + b*b)
    base = -a*A/2 - b*B/2
    threshold = r * norm
    # |base + m| < threshold => -threshold < base + m < threshold
    # => -threshold - base < m < threshold - base
    m_min = -threshold - base
    m_max = threshold - base
    true_text = f"Cho mặt cầu \\((S): x^2+y^2+z^2{A:+}x{B:+}y{C:+}z{D:+}=0\\) và mặt phẳng \\((P): {a}x{b:+}y+m=0\\). Để \\((P)\\) cắt \\((S)\\) theo giao tuyến là đường tròn, cần \\({m_min}<m<{m_max}\\)."
    false_text = f"Điều kiện để \\((P)\\) cắt \\((S)\\) theo giao tuyến là đường tròn là \\(m<{m_min}\\) hoặc \\(m>{m_max}\\)."
    return {"true": true_text, "false": false_text}

# Sphere intersects plane with circle of given area/radius

def prop_sphere_plane_intersection_given_radius() -> Dict[str, str]:
    # Sphere with center I and plane, intersection circle has given radius
    center = (random.choice([1, 2]), random.choice([1, 2]), random.choice([1, 2]))
    r_circle = random.choice([3, 4])  # radius of intersection circle
    # Plane: ax+by+cz+d=0
    a, b, c, d = random.choice([1, 2]), random.choice([1, 2]), random.choice([1, 2]), random.choice([3, 4])
    # Distance from center to plane
    dist = abs(a*center[0] + b*center[1] + c*center[2] + d) / math.sqrt(a*a + b*b + c*c)
    # Sphere radius: R^2 = dist^2 + r_circle^2
    R_sq = dist*dist + r_circle*r_circle
    
    # Format sphere equation properly
    cx_term = f"(x{-center[0]:+})" if center[0] != 0 else "x"
    cy_term = f"(y{-center[1]:+})" if center[1] != 0 else "y"
    cz_term = f"(z{-center[2]:+})" if center[2] != 0 else "z"
    sphere_eq = f"{cx_term}^2+{cy_term}^2+{cz_term}^2={R_sq:.1f}"
    
    true_text = f"Mặt cầu \\((S)\\) có tâm \\(I{format_point(center)}\\) và cắt mặt phẳng \\((P): {format_plane_equation(a,b,c,d)}\\) theo đường tròn có bán kính \\(r={r_circle}\\) có phương trình \\((S): {sphere_eq}\\)."
    false_text = f"Mặt cầu cần thiết có bán kính \\(R={r_circle}\\)."
    return {"true": true_text, "false": false_text}

# Additional generators to reach 15 total (matching tex file)

def prop_sphere_plane_intersection_given_area() -> Dict[str, str]:
    # Intersection circle with given area
    center = (random.choice([1, 2]), random.choice([1, 2]), random.choice([1, 2]))
    area_circle = random.choice([4, 9, 16]) * math.pi  # π, 4π, 9π, 16π
    r_circle = math.sqrt(area_circle / math.pi)
    a, b, c, d = random.choice([1, 2]), random.choice([1, 2]), random.choice([1, 2]), random.choice([2, 3])
    dist = abs(a*center[0] + b*center[1] + c*center[2] + d) / math.sqrt(a*a + b*b + c*c)
    R_sq = dist*dist + r_circle*r_circle
    true_text = f"Mặt cầu tâm \\(I{format_point(center)}\\) cắt mặt phẳng \\((P): {format_plane_equation(a,b,c,d)}\\) theo đường tròn có diện tích \\({int(area_circle/math.pi)}\\pi\\) có bán kính \\(R=\\sqrt{{{R_sq:.1f}}}\\)."
    false_text = f"Đường tròn giao tuyến có diện tích \\({int(area_circle/math.pi)+1}\\pi\\)."
    return {"true": true_text, "false": false_text}

def prop_plane_distance_to_point() -> Dict[str, str]:
    # Distance from point to plane
    a, b, c, d = random.choice([2, 3, 4]), random.choice([1, 2]), random.choice([1, 2]), random.choice([1, 5])
    P = (random.choice([1, 2]), random.choice([1, 2]), random.choice([1, 2]))
    numer, norm_sq = point_plane_distance_numer_normsq(a, b, c, d, P)
    true_text = f"Khoảng cách từ điểm \\(M{format_point(P)}\\) đến mặt phẳng \\((P): {format_plane_equation(a,b,c,d)}\\) bằng \\(\\dfrac{{{numer}}}{{\\sqrt{{{norm_sq}}}}}\\)."
    false_text = f"Khoảng cách từ điểm \\(M{format_point(P)}\\) đến mặt phẳng \\((P): {format_plane_equation(a,b,c,d)}\\) bằng \\(\\dfrac{{{numer+1}}}{{\\sqrt{{{norm_sq}}}}}\\)."
    return {"true": true_text, "false": false_text}

def prop_plane_angle_with_coordinate_plane() -> Dict[str, str]:
    # Angle between plane and coordinate plane
    a, b, c = random.choice([1, 2]), random.choice([1, 2]), random.choice([1, 2])
    d = random.choice([1, 3, 5])
    # Angle with Oxy plane (normal (0,0,1))
    cos_angle = abs(c) / math.sqrt(a*a + b*b + c*c)
    angle_deg = math.degrees(math.acos(cos_angle))
    if abs(angle_deg - 45) < 1:
        angle_text = "45°"
    elif abs(angle_deg - 60) < 1:
        angle_text = "60°"
    elif abs(angle_deg - 30) < 1:
        angle_text = "30°"
    else:
        angle_text = f"{angle_deg:.0f}°"
    true_text = f"Góc giữa mặt phẳng \\((P): {format_plane_equation(a,b,c,d)}\\) và mặt phẳng \\((Oxy)\\) bằng \\({angle_text}\\)."
    false_text = f"Góc giữa mặt phẳng \\((P): {format_plane_equation(a,b,c,d)}\\) và mặt phẳng \\((Oxy)\\) bằng \\(90°\\)."
    return {"true": true_text, "false": false_text}

def prop_sphere_general_form_center_radius() -> Dict[str, str]:
    # Sphere in general form, find center and radius
    u, v, w = random.choice([-2, -1, 1, 2]), random.choice([-2, -1, 1, 2]), random.choice([-2, -1, 1, 2])
    D = random.choice([-5, -3, -1])
    center = (-u, -v, -w)
    r_sq = u*u + v*v + w*w - D
    r = math.sqrt(r_sq)
    sphere_terms = ["x^2+y^2+z^2"]
    if u != 0:
        sphere_terms.append(f"{2*u:+}x")
    if v != 0:
        sphere_terms.append(f"{2*v:+}y")
    if w != 0:
        sphere_terms.append(f"{2*w:+}z")
    sphere_terms.append(f"{D:+}")
    sphere_eq = "".join(sphere_terms) + "=0"
    true_text = f"Mặt cầu \\((S): {sphere_eq}\\) có tâm \\(I{format_point(center)}\\) và bán kính \\(R={r:.1f}\\)."
    false_text = f"Mặt cầu \\((S): {sphere_eq}\\) có tâm \\(I{format_point((center[0]+1, center[1], center[2]))}\\)."
    return {"true": true_text, "false": false_text}

def prop_plane_through_three_points() -> Dict[str, str]:
    # Plane through three non-collinear points
    A = (random.choice([1, 2]), 0, 0)
    B = (0, random.choice([1, 2]), 0)
    C = (0, 0, random.choice([1, 2]))
    # Plane equation: x/A[0] + y/B[1] + z/C[2] = 1
    # or A[0]*B[1]*C[2]*x + A[0]*C[2]*y + B[1]*C[2]*z - A[0]*B[1]*C[2] = 0
    # Simplified: B[1]*C[2]*x + A[0]*C[2]*y + A[0]*B[1]*z - A[0]*B[1]*C[2] = 0
    a = B[1] * C[2]
    b = A[0] * C[2]
    c = A[0] * B[1]
    d = -A[0] * B[1] * C[2]
    true_text = f"Phương trình mặt phẳng đi qua ba điểm \\(A{format_point(A)}\\), \\(B{format_point(B)}\\), \\(C{format_point(C)}\\) là \\((P): {format_plane_equation(a,b,c,d)}\\)."
    false_text = f"Phương trình mặt phẳng đi qua ba điểm trên là \\((P): {format_plane_equation(a,b,c,d-1)}\\)."
    return {"true": true_text, "false": false_text}

PART_C_GROUPS: List[List] = [
    [prop_tangent_plane_at_point],
    [prop_plane_parallel_tangent_to_sphere],
    [prop_radius_from_center_plane_distance],
    [prop_plane_sphere_no_intersection_param],
    [prop_plane_parallel_equidistant_two_planes],
    [prop_plane_sphere_intersection_circumference],
    [prop_plane_through_points_equidistant],
    [prop_param_plane_tangent_sphere],
    [prop_param_plane_intersect_sphere_circle],
    [prop_sphere_plane_intersection_given_radius],
    [prop_sphere_plane_intersection_given_area],
    [prop_plane_distance_to_point],
    [prop_plane_angle_with_coordinate_plane],
    [prop_sphere_general_form_center_radius],
    [prop_plane_through_three_points]
]


def generate_question(question_number: int) -> str:
    # Chọn 1 nhóm mapping trong phần C, lấy 1 mệnh đề từ nhóm đó
    selected_group = random.choice(PART_C_GROUPS)
    primary_gen = random.choice(selected_group)
    # Pool còn lại: tất cả generator của phần C trừ nhóm đã chọn
    all_gens: List = []
    for grp in PART_C_GROUPS:
        for g in grp:
            all_gens.append(g)
    remaining_pool = [g for g in all_gens if g not in selected_group]
    if len(remaining_pool) >= 3:
        other_gens = random.sample(remaining_pool, 3)
    else:
        other_gens = [random.choice(remaining_pool) for _ in range(3)] if remaining_pool else [primary_gen]*3
    selected_gens = [primary_gen] + other_gens
    props: List[Dict[str, str]] = [gen() for gen in selected_gens]
    num_true = random.randint(1, 4)
    true_indices = set(random.sample(range(4), num_true))
    labels = ['a', 'b', 'c', 'd']
    content = f"Câu {question_number}: Chọn các mệnh đề đúng.\n\n"
    for i in range(4):
        txt = props[i]['true'] if i in true_indices else props[i]['false']
        mark = '*' if i in true_indices else ''
        content += f"{mark}{labels[i]}) {txt}\n\n"
    return content


def create_latex_document(questions: List[str], title: str = "Tương giao mặt phẳng và mặt cầu - Đúng/Sai") -> str:
    latex = (
        "\\documentclass[a4paper,12pt]{article}\n"
        "\\usepackage{amsmath,amssymb}\n"
        "\\usepackage{geometry}\n"
        "\\geometry{a4paper, margin=1in}\n"
        "\\usepackage{polyglossia}\n"
        "\\setmainlanguage{vietnamese}\n"
        "\\setmainfont{Times New Roman}\n"
        "\\begin{document}\n\n"
        f"\\section*{{{title}}}\n\n"
    )
    latex += "\n\n".join(questions)
    latex += "\n\n\\end{document}"
    return latex


def generate_all_propositions() -> List[str]:
    """Generate all proposition types exactly once without repetition"""
    all_generators = []
    for group in PART_C_GROUPS:
        for gen in group:
            all_generators.append(gen)
    
    questions = []
    for i, gen in enumerate(all_generators):
        # Generate both true and false versions of each proposition
        prop = gen()
        
        # Create a question with both true and false versions
        question_content = f"Câu {i+1}: Chọn các mệnh đề đúng.\n\n"
        question_content += f"*a) {prop['true']}\n\n"
        question_content += f"b) {prop['false']}\n\n"
        
        # Add two more false statements from other generators to make it 4 options
        other_gens = [g for g in all_generators if g != gen]
        if len(other_gens) >= 2:
            import random
            # Use current time as seed to avoid pure randomness but ensure variety
            import time
            random.seed(int(time.time()) + i)
            selected_others = random.sample(other_gens, 2)
            
            for j, other_gen in enumerate(selected_others):
                other_prop = other_gen()
                question_content += f"{chr(ord('c') + j)}) {other_prop['false']}\n\n"
        
        questions.append(question_content)
    
    return questions


def main():
    import sys
    
    # Check if 'all' option is used
    if len(sys.argv) > 1 and sys.argv[1].lower() == 'all':
        qs = generate_all_propositions()
        title = "Tương giao mặt phẳng và mặt cầu - Tất cả các dạng bài"
    else:
        # Original behavior for random questions
        try:
            num_questions = int(sys.argv[1]) if len(sys.argv) > 1 else 5
        except Exception:
            num_questions = 5
        qs = [generate_question(i+1) for i in range(num_questions)]
        title = "Tương giao mặt phẳng và mặt cầu - Đúng/Sai"
    
    tex = create_latex_document(qs, title)
    out = "plane_true_false_part_C.tex"
    with open(out, "w", encoding="utf-8") as f:
        f.write(tex)
    print(f"Generated {out} with {len(qs)} question(s). Compile with XeLaTeX.")


if __name__ == "__main__":
    main()
